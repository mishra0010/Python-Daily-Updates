 LeetCode Problem: Product of Array Except Self
ðŸ§¾ Problem Statement:
Given an integer array nums, return an array answer such that answer[i] is equal to the product of all elements in nums except nums[i].

Important Constraints:
The product of any prefix or suffix of nums will fit in a 32-bit integer.
The solution must have a time complexity of O(n).
Division is not allowed.

ðŸ’¡ Examples:
Example 1:

Input:  nums = [1, 2, 3, 4]
Output: [24, 12, 8, 6]

Example 2:

Input:  nums = [-1, 1, 0, -3, 3]
Output: [0, 0, 9, 0, 0]

âœ… Constraints:
2 <= nums.length <= 10^5
-30 <= nums[i] <= 30
The output is guaranteed to fit in a 32-bit integer.


ðŸ› ï¸ Solution Approaches:
1. Brute Force Approach (O(nÂ²) Time | O(n) Space)
This naive solution uses nested loops to calculate the product of all elements except the one at index i.

For each element at index i, iterate through the entire array.

Skip the index i, and multiply all other elements.

Store the result in a new array and return it.

class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        n = len(nums)
        res = [0] * n

        for i in range(n):
            prod = 1
            for j in range(n):
                if i == j:
                    continue
                prod *= nums[j]
            res[i] = prod
        return res

âš ï¸ This approach works correctly but is inefficient for large arrays due to its O(nÂ²) time complexity.

2. Optimized Approach Using Prefix and Postfix Products (O(n) Time | O(1) Extra Space)
This method efficiently computes the result by using two passes:

First pass (left to right): Compute the prefix product for each element.
Second pass (right to left): Multiply with the postfix product.

Key Idea:

res[i] should be equal to the product of all elements before i (prefix) and all elements after i (postfix).


class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        res = [1] * len(nums)
        
        # Compute prefix products
        prefix = 1
        for i in range(len(nums)):
            res[i] = prefix
            prefix *= nums[i]
        
        # Compute postfix products and multiply with result
        postfix = 1
        for i in range(len(nums) - 1, -1, -1):
            res[i] *= postfix
            postfix *= nums[i]
        
        return res
âœ… This approach meets all constraints:

Runs in linear time O(n)
Does not use division
Uses only constant extra space (excluding output array)
